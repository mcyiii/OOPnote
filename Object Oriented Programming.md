# オブジェクト指向の基礎と応用

オブジェクト指向は、ソフトウェアの大規模化、複雑化に伴って生まれたパラダイム(やり方や考え方の枠組み)として知られている。そのため、ソフトウェアの開発や運用保守に対して、規模や複雑さによらず、大きな効果を発揮するための要素を備えているといえる。その中でも重要なのは、コードをよりよく整理するための、体系化やドメイン駆動である。これらは、理解、変更、修正、拡張、検証のしやすさを大幅に改善したり、コードの無駄やバグを減らしたり、さらには非常に便利なライブラリを作成、利用したりすることができる。体系化やドメイン駆動はのちに詳しく学ぶため、言葉だけ知っておくとよい。

この文章は、3章で構成される。1章では、古い方法が大規模化、複雑化するソフトウェアに対応できない理由を明らかにして、オブジェクト指向の必要性を説明する。2章では、オブジェクト指向の基本概念を機能的側面から説明し、整理された正しい理解を促す。3章では、ここまでに学んだオブジェクト指向の知識を整理して、有効に活用していくための知識や考え方を議論する。

1章の中心概念は、型システムである。型システムというのは、多くのプログラミング言語がもつ原始的な機能である。1章の目標は、型システムの仕組み(何がどうなっているのか)とその目的(何をしようとしているのか)、さらには単純な型システムの課題と解決のための複雑な型システムを理解することである。実は、単純な型システムの課題を解決するために、オブジェクト指向は複雑な型システムをもつ。1章の内容を理解することで、オブジェクト指向の複雑さを正しく認識でき、学習に自信をもって取り組むことができるようになる。

2章の中心概念は、クラスとオブジェクトである。クラスとオブジェクトは、オブジェクト指向の基本概念の中でも、最も基礎的な要素である。2章の目標は、クラスの考え方(クラスを理解するとはどういうことか)を身につけること、それから、クラスとオブジェクトの機能を理解することである。特に、クラス同士の関係であるis-a関係とhas-a関係、オブジェクト同士の関係であるメッセージパッシングとディスパッチについて学び、これらを基礎に全体像を把握する。2章の内容を理解することで、クラスとオブジェクトの正確な知識を身につけ、すっきりと考えられるようになる。

3章の中心概念は、設計と評価である。設計というのは、どのようなクラスが必要か、どのようにクラスを組み合わせるかについて計画することだ。評価というのは、設計の良し悪しを根拠をもって客観的に判断する方法である。3章の目標は、頭の中で設計の基本的なパターンを整理し、評価の方法を身につけ、よい設計を考える能力を養うことである。設計の基本的なパターンは、2章の内容を設計のために整理し直したものだと考えてもよい。評価には、ソフトウェア工学と呼ばれる分野の概念を取り入れる。3章の内容を理解することで、設計の基本的な方法を身につけ、よい設計と悪い設計の判断ができるようになる。しかし、よい設計ができるようになるためには、内容を理解するだけでなく、よく考えて試行錯誤する必要もある。

## 1章: 型システム

型システムというのは、多くのプログラミング言語がもつ原始的な機能である。1章の目標は、次の4つを理解することだ。

- 型システムの仕組み(何がどうなっているのか)
- 型システムの目的(何をしようとしているのか)
- 単純な型システムの課題
- 複雑な型システムによる解決

これらの目標によって、次が期待される。

- オブジェクト指向の複雑さに正しく向き合うことができる。
- 自信をもって学習を進めることができる。

### 関数と型安全性

型システムの前に、関数について考えてみよう。関数もまた、多くのプログラミング言語がもつ機能であるが、ここでは引数を受け取って返り値を返すもののことをいう。言語によってはそれだけの機能ではないかもしれないが、今は引数と返り値に注目するのだと考えてほしい。また、ここでは、関数の引数に与えられたり、返り値になったりするようなものを値と呼ぶ。値に含まれるものは言語によって異なるが、定数や変数を想像すればよい。

(単純な)型システムは、プログラムについて次のルールを自動的に確認する仕組みである。

- すべての値には型が決められている。
- すべての関数には引数の型と返り値の型が決められている。
- 関数の引数に値が渡されるとき、値に決められている型と、関数に決められている引数の型は、一致している。

実は、型システムは、値や関数の使い方を適切に制限するため(別な言い方をすれば、望まない使い方を禁止するため)に存在する。値や関数の使い方というのは、引数に何かを入れて、返り値を受け取ったり、返り値を他の関数の引数に渡したりすることだ。特に、単純な型システムのルールに基づけば、関数の引数には型が一致する値しか渡すことができないように、値や関数の使い方を制限できる。このとき、その制限が適切であるためには、型が適切に決められている必要がある。したがって、型が適切に決められているのであれば、値や関数がプログラムの中で正しく使われていることを型システムで自動的に確認できるといえる。このように、プログラムの中でその要素(値や関数)が正しく使われているという性質を型安全性という。この言葉を用いれば、型システムは型安全性の実現を目的に存在すると説明できる。

例えば、square(x)という関数があるとしよう。この関数は、xとxを掛けた結果を返すものだ。すると、square(2)は4を返し、square(2.3)は5.29を返す。ここで、square("あいうえお")はどうなるだろうか。エラーになるかもしれないし、変な値を返すかもしれない。しかし、型が適切に決められていれば、型システムが自動的に確認できる。他にも、2cm+8kgのような単位付きの値や、画像の表示(../example.xlsx)のような拡張子の誤りにも自動的に反応でき、さらには、使用される状況を特定することでバグを減らすこともできる。例えば、ゲームのレーティングシステムで、スコアと古いレートから新しいレートを計算する関数があるとしよう。レートの計算方法は変更される可能性があり、この関数がスコアと古いレートから新しいレートを計算する用途以外に使われると、バグが発生する可能性が非常に高くなる。こんなとき、関数の引数をスコア情報とレート情報しか渡せないようにすれば、レートの計算にしか使えないようにでき、安心してレートの計算方法を変更できる。

型システムが本当に、プログラムの型安全性を実現する(プログラムの中ですべての要素が正しく機能することを、自動的に、しかも確実に保証できる)としたら、すごいことではないだろうか。ソフトウェアが大規模で複雑になったとしても、自動的であるから人手やコストに影響がほとんどなく、しかも間違えることなく確実に、安全性の保証が手に入る。そして、安全性の保証が簡単に手に入るのならば、テストやデバッグは不要になり、不可解なエラーは起こらなくなる。さらに、開発の生産性を向上させ、修正や拡張といった変更のコストを抑えられる。しかし、それほどの型安全性は、単純な型システムでは到底得られない。単純な型システムは課題を抱えているからだ。

### 単純な型システムの課題

型システムは型安全性の実現が目的であった。型安全性を実現するためには、プログラムの中で値や関数が正しく使われるように、関数の引数に渡すことができる値を適切に限定する必要がある。この限定をどれだけ緻密に設定できるかというのは、型システムの能力として重要である。この能力を、型システムの表現力という。単純な型システムの表現力は不十分で、単純な型システムの課題となっている。より強固な型安全性を実現するためには、より表現力の高い型システムが必要になる。

例を挙げてみよう。xとxを掛けた結果を返す関数square(x)は、xがint型のパターンとdouble型のパターンで引数に渡せるようなものだとする。このとき、単純な型システムでは、square_int関数とsquare_double関数をつくるという方法がある。単純な型システムでも少し拡張したものでは、言語によっては、xがint型のパターンのsquare関数と、double型のパターンのsquare関数を別につくることができる。しかし、これでは型の種類に合わせて関数を何度も定義しなければならなくなる。特に、square関数であれば、xとxを乗算して結果を返すだけでいいので、int型でもdouble型でも、コードは全く同じになる。このように、関数にほかのパターンを追加する度に無駄なコードが生まれ、どのようなパターンに対応しているのかも不透明になってしまう。つまり、関数の使い方を適切に限定するのが難しく、単純な型システムの表現力に限界があるというのがわかる。特に、型が増えるとパターンも増えてしまうため、必然的に型の種類が少なくなり、関数の使い方を細かく制限できないことにつながって、単純な型システムの表現力を抑えてしまう。

このように、型安全性を実現するという目的では、細かな限定を苦手とする単純な型システムは表現力に限界がある。1つの関数について、1つの型のパターンでしか限定できず、型安全性のために多くの無駄なコードを書かなくてはならなくなる。また、型の種類が多いほど強固な型安全性の実現に近づくにもかかわらず、型の種類が多ければ無駄なコードが増えるのも、単純な型システムの課題だといえる。

### 複雑な型システムと多相

単純な型システムが抱える課題は、関数の引数に渡すことができる値を緻密に限定するのが難しいということ、そしてそのために型安全性が強固にならないということであった。だからといって、型安全性を放棄するわけにはいかない。

単純な型システムが確認するルールは次の3つであった。

- すべての値には型が決められている。
- すべての関数には引数の型と返り値の型が決められている。
- 関数の引数に値が渡されるとき、値に決められている型と、関数に決められている引数の型は、一致している。

単純な型システムの課題を解決するために、ルールをより複雑にした型システムがいくつかある。ここでは2つを簡単に紹介し、それぞれの解決の方法を知ってもらう。

1つ目は、型の関係として、一方の型がもう一方の型の代わりになることができると決めておくものである。この型システムが確認するのは、次のルールである。

- すべての値には型が決められている。
- すべての関数には引数の型と返り値の型が決められている。
- 関数の引数に値が渡されるとき、次のどちらかである。
  - 値に決められている型と、関数に決められている引数の型は、一致している
  - 値に決められている型が、関数に決められている引数の型の代わりになることができる。

このルールでは、関数の引数に渡すことができる値を、決められた型だけでなく、その型の代わりになることができる型でもよいものして限定することができる。例を見よう。関数square(x)は、xがint型のパターンとdouble型のパターンで制限されているとする。ところで、Number型というものがあるとしよう。関数square(x)は、xがNumber型だとして、xとxを乗算した結果を返すように定義しておく。また、int型とdouble型は、どちらもNumber型の代わりになることができると決めておこう。すると、square(x)はint型でもdouble型でも利用できるようになる。このような型システムでは、型を他の型の代わりになることができると決めておくだけで、今までの多くの関数を利用でき、必要になるたびに対応したり、無駄なコードを加えたりする必要もない。さらに、多くの型に対応した関数も、無駄なコードなく定義できる。

2つ目は、型の条件として、その型で特定の関数が使えるかどうかを利用するものである。この型システムが確認するのは、次のルールである。このルール内の型の条件というのは、特定の関数が使えることを表す。

- すべての値には型が決められている。
- すべての関数には返り値の型が決められていて、次のどちらかである。
  - 引数の型が決められている。
  - 引数の型は決められていないが、引数の型に型の条件が決められている。
- 関数の引数に値が渡されるとき、次のどちらかである。
  - 関数の引数に型が決められている場合、値に決められている型と、関数の引数に決められている型が、一致している。
  - 関数の引数に型が決められていないが、型に条件が決められている場合、値に決められている型が、型の条件を満たしている。

このルールでは、関数の引数に渡すことができる値を、決められた型だけでなく、特定の関数を使うことができる型としても限定できる。例を見よう。関数square(x)は、xとxを乗算した結果を返すというものだとする。ここで、xの型で乗算の関数が使えるという型の条件を、square関数の引数の条件とすることができる。すると、square関数はint型やdouble型にも対応している。このような型システムでは、その型で特定の関数を使えるようにするだけで多くの関数を利用でき、必要になるたびに対応したり、無駄なコードを加えたりする必要もない。さらに、多くの型に対応した関数も、無駄なコードなく定義できる。

これらの型システムは、値や関数の使い方をより緻密に制限し、強固な型安全性を実現できる。あるいはそれ以上に、関数の使い方をより柔軟にし、既存の関数を利用するための面倒な対応や無駄なコードを不要にする。このような柔軟な関数の使い方を多相という。多相の考え方はのちに詳しく学ぶので、言葉だけでも知っておくとよい。

### 1章のまとめ

1章の目標は、次の4つであった。それぞれについて、簡単にまとめよう。

- 型システムの仕組みを理解すること。
  - 型システムの仕組みは、プログラムについての決められたルールを自動的に確認するものだ。このルールによって、型システムの複雑さや表現力が異なってくる。
- 型システムの目的を理解すること。
  - 型システムの目的は、型安全性を実現することだ。型安全性というのは、プログラムの中で値や関数といった要素のすべてが正しく使われている、というプログラムのもつべき性質である。
- 単純な型システムの課題を理解すること。
  - 単純な型システムの課題とは、単純な型システムでは、型安全性を十分に実現することができないということだ。その理由は、そのような型システムはルールが単純なあまり、表現力が不足しているからである。表現力というのは、プログラムの中で値や関数といった要素の使い方をどれだけ緻密に制限できるかということである。
- 複雑な型システムによる解決を理解すること。
  - 複雑な型システムでは、ルールを複雑にすることで、表現力を強め、単純な型システムの課題を解決した。ルールは紹介したものの他にも考えることができる。このような複雑な型システムでは、結果的に、値や関数といったプログラムの要素の使い方をより柔軟に、効率的にするということにも触れた。

ここまでの学習で、型安全性の実現がソフトウェアの大規模化、複雑化に対応する有効で有望な方法だということがわかるだろう。自動的で確実な安全性の確保ができ、テストやデバッグの負担を減らしたり、不可解なエラーをなくしたり、生産性を向上させたり、修正や拡張をより容易に安心して行えるようになるなど、型安全性の実現の恩恵は非常に大きい。そして、オブジェクト指向もまた、複雑な型システムを取り入れて型安全性を実現しようとしている。型安全性は、ただの仕組みだけでなく、プログラムの作成者が正しい知識と理解をもっていなければ実現できない。オブジェクト指向は、複雑な型システムの仕組みをよりわかりやすい機能にし、その機能の使い方や考え方とともにまとめられた知識体系である。2章では、これまでの内容を振り返りつつ、オブジェクト指向の機能について学んでいく。使い方や考え方については3章で学ぶことになる。

## 2章: クラスとオブジェクト

クラスとオブジェクトは、オブジェクト指向の基本概念の中でも、最も基礎的な要素である。2章の目標は、次の3つを理解することだ。

- クラスの考え方(クラスを理解するとはどういうことか)
- クラスとオブジェクトの機能
  - クラス同士の関係であるis-a関係とhas-a関係
  - オブジェクト同士の関係であるメッセージパッシングとディスパッチ

これらの目標によって、次が期待される。

- オブジェクト指向を正確に理解できる。
- オブジェクト指向について、すっきりと考えることができる。

### 型とクラス

まずは、クラス、オブジェクト、属性、メソッド、ふるまいという、オブジェクト指向の用語の存在を理解してほしい。用語についてざっくりと確認しよう。

- クラス
  - クラスは、オブジェクトを生成することができる。
  - クラスは、生成したオブジェクトのふるまいを完全に決める。
  - クラスは、属性やメソッドを利用して、ふるまいを決める。
- オブジェクト
  - オブジェクトは、クラスによって生成される。
  - オブジェクトは、そのふるまいがクラスによって完全に決められている。
  - オブジェクトは、ふるまいとして決められたような使い方しかできない。
- 属性
  - 属性は、クラスに属するオブジェクトである。
  - 属性は、クラスがふるまいを決めるために利用される。
- メソッド
  - メソッドは、クラスに属する関数である。
  - メソッドは、クラスがふるまいを決めるために利用される。
- ふるまい
  - ふるまいは、オブジェクトの使い方のことである。
  - ふるまいは、クラスによって完全に決められる。

不完全な例になるが、クラスは変数と関数の集まりで、クラス内の変数を属性、クラス内の関数をメソッドとよび、変数のプログラム内での使い方をその変数のふるまい、変数をオブジェクト指向ではオブジェクトとよぶのだと考えてもよい。

さらに不完全でいずれ混乱を招く例ではあるが、クラスはよく、設計図に例えられる。自動車の設計図がクラスであれば、実際に組み上がった自動車はオブジェクトに対応する。自動車のクラスは属性にハンドルやシート、タイヤなどがあり、メソッドに前進や停止やリクライニングなどがあるといえる。また、前進や停止やリクライニングなどはふるまいの一部でもある。ただし、これらは非常におおざっぱで乱雑な例であるため、参考にとどめておくとよい。

さて、1章では、型システムについて学んだ。型システムの目的は、型安全性の実現であった。型安全性の実現のためには、値や関数といったプログラムの要素が正しく使われるように、関数の使い方を制限する必要があった。そして、その制限のために使われるのが、型である。型の種類が多いほど、関数の使い方をより緻密に制限できるということも学んだ。

クラスとは、型のようなものである。つまり、クラスは、プログラムの要素の使い方を制限するためにある。特に、オブジェクト指向の用語では、そのような要素は主にオブジェクトという用語に置き換わる。そのため、クラスはオブジェクトのふるまいを完全に決めることを目的にしている。オブジェクト指向では、型安全性というのはまさに、たくさんのクラスがそれぞれ、そのふるまいを正しく適切に、完全に決めているということを表す。クラスがふるまいを決めることと型安全性は直結しているということは、覚えておくとよい。

オブジェクト指向では、クラスを理解することが最も重要である。なぜなら、クラスがオブジェクトのふるまいを完全に決めているからだ。しかし、クラスを理解するとは、どういうことだろうか。それは、クラスが決めたふるまいの全体を把握するということだ。なんらかのクラスを理解したいとすれば、そのクラスがどのようにふるまいを決めているのか、どのようなふるまいを決めているのかさえ把握すればよい、ということになる。これからは、これを意識してほしい。

クラスは、ふるまいを決めるために属性やメソッドを利用する。また、他のクラスとの関係からも、ふるまいが決められる。これから、クラスがふるまいを決めるための仕組みについて学ぶということになる。まずは、メソッドからふるまいが決められるということについて学ぼう。

### クラスとメソッド

クラスの理解は、そのオブジェクトのすべてのふるまいを理解することである。また、クラスがふるまいを完全に決めることが、型安全性に直結する。ここから導かれる結論は、クラスが決めるふるまいは緻密に管理されるべきだということだ。なぜなら、クラスが決めるふるまいというのはそのクラスの理解しやすさに関わり、ふるまいをむやみに増やして複雑化すれば、理解が難しくなってしまうからだ。それから、型安全性はそもそも、関数の使い方を緻密に制限することで強固になるのだったから、ふるまいについても同様である。クラスが決めるふるまいを細かく管理し、理解しやすくしたり、制限したりするべきなのだといえる。

これは、オブジェクト指向では、アクセス指定という機能によって実現される。アクセス指定は、メソッドの使い方を緻密に管理するための機能で、メソッドがオブジェクトから利用できるかどうかを指定するものだ。つまり、メソッドがふるまいとなるかどうかは、アクセス指定による。クラスを理解するためには、すべてのふるまいを理解すればよいのであったから、アクセス指定はクラスの理解にとっても重要だ。また、アクセス指定はメソッドだけでなく、属性に対しても指定できる。しかし、属性のオブジェクトは多くのふるまいをもってしまうため、ふるまいを理解しやすくしたり、ふるまいを制限したりするのが難しい。だから、属性は多くの場合、外部から直接アクセスできないようにされる。つまり、多くの場合、ふるまいとはアクセス指定で選ばれた一部のメソッドのことになる。

ここでは、メソッドから決められるふるまいについて学習した。クラスを理解するためには、全体的にふるまいを把握することが重要であった。クラスは、メソッドのほかに、クラス間の関係からふるまいを決めることができる。次は、そのようなクラス間の関係について学ぶ。クラス間の関係を理解することで、ふるまいがどのように決められるのかをさらによく理解できる。

### クラス間のis-a関係とhas-a関係

is-a関係とhas-a関係は、クラス同士の関係性である。クラス同士の関係性とは、そのクラスのオブジェクトのふるまいを間接的に定めるもので、特に一方が他方に影響を与える関係になる。A is-a BやA has-a Bでは、クラスAのふるまいがクラスBによって決められる。クラスを理解するには、そのクラスの定めるすべてのふるまいを理解すればよいので、ふるまいがどんな影響を受けるのかを整理しよう。A is-a Bでは、クラスAがクラスBのすべてのふるまいを決めていて、クラスAはクラスBの代わりにもなることができる。A has-a Bでは、一方のクラスにもう一方のクラスのすべて、または一部のふるまいを決める、または何も決めないことができる。これを読んでわかるように、has-a関係はis-a関係の完全な上位互換であるともいえる。is-a関係は、代わりになることができるという点が重要である。

is-a関係とhas-a関係について、例を挙げて説明しよう。AnimalクラスとDogクラスがあるとしよう。このとき、Dog is-a Animalであるとは、DogクラスがAnimalクラスのすべてのふるまいを定めていて、DogクラスのオブジェクトはAnimalクラスのオブジェクトのように完全にふるまうことができる。つまり、DogクラスのオブジェクトはAnimalクラスのオブジェクトの代わりになることができる。is-a関係は代わりになってふるまうことができるという特徴を理解しておくとよい。Animalクラスがふるまいとしてsleepメソッドのみを定める場合には、Dogクラスもsleepメソッドを定めることになる。さらに、Animalクラスに新たなふるまいを追加すると、Dogクラスでもそのふるまいが自動的に定められる。

また、CarクラスとDoorクラスがあるとしよう。このとき、Car has-a Doorであるとは、CarクラスがDoorクラスのふるまいの中から選択的にふるまいを定めていたり、いなかったりする。例えば、Doorクラスのふるまいがopenメソッドのみである場合、Carクラスはopenメソッドをそのまま使うようにするかもしれない。例えば、Doorクラスのふるまいがweldメソッド(溶接する)のみである場合、Carクラスのふるまいには取り入れないかもしれない。

これらの例において、場合によってはDog has-a AnimalやCar is-a Doorであっても機能的に変わらないように思われる。しかし、修正や拡張の結果、is-a関係ではなくなる可能性がある場合、初めからhas-a関係にしておいた方がよいといえる。また、is-a関係であることが必然的な場合には、has-a関係では不便が多くなる。どちらが適切であるかは、多くの場合に、作成するプログラムによって変わることを覚えておくとよい。

このように、is-a関係は、クラスA,BについてA is-a Bならば、AはBのすべてのふるまいを定めていて、AはBの代わりとして安全に使えることが自動的に保証される。has-a関係は、クラスA,BについてA has-a Bならば、AはBのふるまいをすべてでも、一部でも、選択的に取り入れたり、取り入れなかったりできるが、ふるまいをメソッドとしてすべて記述する必要がある。

ここで、is-a関係とhas-a関係の正体を明かすと、is-a関係は継承と呼ばれ、has-a関係はオブジェクトを属性にもつということになる。実際にプログラムを書くとき以外は、is-a関係とhas-a関係で考えるのがよい。

### オブジェクト間のメッセージパッシングとディスパッチ

オブジェクトのふるまいからメソッドを呼び出すことをメッセージパッシングという。オブジェクト指向は、ふるまいのメソッドの呼び出しをメッセージの送受信に見立てて、複数のオブジェクトがメッセージのやりとりによって処理を行うという説明をする。そして、メッセージのやり取りとして図式化することも多いため、知っておくとよい。

メッセージパッシングでは、is-a関係やhas-a関係が関わると、ディスパッチと呼ばれる機能がはたらく。ディスパッチは、メッセージパッシングに対する実際の動作をオブジェクトの種類によって変化させる。is-a関係やhas-a関係では、同様のふるまいをクラスが決めることがあった。それに対応し、オブジェクトがどのクラスで生成されたかに応じて、メッセージパッシングに対する実際の動作を選択する。

例を挙げて説明しよう。Animalクラス、Dogクラス、Catクラスがあるとして、Dog is-a AnimalとCat is-a Animalの関係があるとしよう。そして、それぞれにふるまいとして、クラス名を返すnameメソッドがあるとしよう。また、それぞれが生成したオブジェクトをanimalとdogとcatとしよう。このとき、animalのnameとdogのnameとcatのnameは、それぞれを生成したクラスで決められた動作をし、対応するAnimalとDogとCatを返すことになる。

Carクラス、Engineクラス、brokenEngineクラス、powerEngineクラスがあるとして、Car has-a EngineとbrokenEngine is-a EngineとpowerEngine is-a Engineの関係があるとしよう。そして、Engineクラス、brokenEngineクラス、powerEngineクラスのそれぞれにふるまいとして、startメソッドがあるとしよう。また、Carクラスには属性のEngineクラスのstartメソッドを利用する、moveメソッドがあるとしよう。このとき、Carクラスのオブジェクトは、属性にもつオブジェクトがEngineクラスであるか、brokenEngineクラスであるか、powerEngineクラスであるかによって、moveメソッドの動作が異なることになる。

このように、オブジェクトは生成されるクラスによって、メッセージパッシングの動作を変えることができる。これをディスパッチという。ディスパッチは、1章の最後に見た多相の考え方に近く、オブジェクト指向ではよく利用することになる。

### その他の基本概念

ここまでで、クラスとオブジェクトについては深く理解できたことだと思う。これからは、2章の内容を前提に、オブジェクト指向の用語を説明する。これまでの復習のついでだと考えて目を通してほしい。

インスタンスは、オブジェクトのことである。クラスによって生成され、そのふるまいが決められている。メッセージパッシングによって処理を行う。

カプセル化は、クラスをつくることである。より正確には、複雑につくられた機能をクラスとしてまとめることを表す。クラスとしてまとめることで、複雑な部分をクラスの内部で完結させ、ふるまいとして扱いやすくすることができる。多くの場合、アクセス指定を活用する。

継承は、is-a関係をプログラムに記述するための、言語の機能である。クラスAがクラスBを継承するとは、A is-a Bを表す。このとき、A/Bをサブクラス/スーパークラス、子クラス/親クラス、下位クラス/上位クラス、派生クラス/基底クラスなどという。is-a関係では、BのふるまいをAでも利用することができ、AがBの代わりになることができると考えることもできた。

抽象クラスは、オブジェクトを生成できないようにしたクラスのことである。抽象クラスには、抽象メソッドという、名前と引数と返り値の型のみを指定した、実装のないメソッドが決められている。抽象メソッドの実装は、必ずサブクラスに記述されなければならない。is-a関係では、スーパークラスのオブジェクトは生成する必要がないようなことが多く、ふるまいだけを決めておき、実際にはサブクラスからのみオブジェクトを生成して利用することがある。抽象クラスでないようなクラスを、具象クラスと呼ぶ。

オーバーライドは、スーパークラスがもつふるまいをサブクラスで上書きすることである。オーバーライドによって、ディスパッチが活用できる。しかし、引数と返り値の型は上書きできない。is-a関係とは無関係に、同名で引数と返り値の型が同じメソッドを定義するのは、オーバーロード(多重定義)という異なる概念であることに注意する。

多態性は、ディスパッチを活用することである。ポリモーフィズムともいう。

集約は、has-a関係のことである。アグリゲートともいう。

委譲は、has-a関係を利用して、クラスから一部のふるまいを選択的に取り入れるというものである。is-a関係では、クラスのふるまいをすべて取り入れることになる点で、委譲と異なる。デリゲートともいう

関連は、is-a関係とhas-a関係のどちらかの関係があることを表すものである。おおざっぱな言葉で、場合によっては特に関係がないこともある。何も決まっていないようなときにも使われる。

インターフェースは、実装のないメソッドの集まりである。抽象クラスのように扱えるが、クラスではなく、クラスに対して複数のインターフェースを実装することもできる。インターフェースはクラスに決められたメソッドが実装されていることを表し、それを関数の引数の型の条件にすることができる。つまり、クラスにインターフェースを実装すると、インターフェースで制約された関数を利用することができる。

### 2章のまとめ

クラスは、そのオブジェクトのふるまいを完全に決める。このおかげで、多種多様なクラスについて理解しやすくなり、型安全性として自動的により強固な安全性を確保することができる。また、オブジェクトのふるまいはクラス間のis-a関係やhas-a関係で決められることもある。ふるまいはメッセージとして送受信され、オブジェクトの属するクラスによってメッセージに対応する動作を選択するディスパッチについても学んだ。

## 3章: 設計とその評価

設計というのは、どのようなクラスが必要か、どのようにクラスを組み合わせるかについて計画することだ。評価というのは、設計の良し悪しを根拠をもって客観的に判断する方法である。3章の目標は、次の3つを身につけることである。

- 設計の基本的なパターン
- 評価の方法
- よい設計を考える能力

これらの目標によって、次が期待される。

- 設計の基本的な方法を利用できる。
- よい設計と悪い設計を客観的に判断できる。

### 指針とパターン

### 原則と評価

### 汎用的な概念

## 付録: オブジェクト指向の拡張
